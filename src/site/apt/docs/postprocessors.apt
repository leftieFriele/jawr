																		------
                                    Postprocessors
                                    ------
                                    ------
                                    ------

Jawr Postprocessors

	Postprocessors are filters that Jawr applies to resources and bundles during startup. These filters provide such things as minification (removal of 
	unneeded whitespace and comments), URL rewriting, and the like. There are two types: file and bundle postprocessors. The file postprocessors are 
	applied to resources before adding them to the bundle. On the other hand, bundle postprocessors are applied to a whole bundle once all the files 
	have been joined into it. \ 
	
	Normally, you will not need to worry about postprocessors, since Jawr will use them automatically. But still, if you have special needs you can 
	configure which postprocessors to use. Also, in the future more of them will be added to Jawr, adding for example integration with the YUI 
	compressor. For configuration purposes, every postprocessor has a unique name key, which you use in a comma-separated property in the descriptor, 
	for instance: 

+------------------------------------------+
	jawr.js.bundle.factory.bundlepostprocessors=JSMin, license
		
	jawr.css.bundle.factory.bundlepostprocessors=cssminify, license
	jawr.css.bundle.factory.filepostprocessors=csspathrewriter
+------------------------------------------+
	
	As you see, we specify a couple of bundle posprocessors for both js and css resources, plus a file postprocessor for css files. We didn't specify 
	any file postprocessor for javascript because, at the time of writing, there is none available yet. \ 
	Note that the previous example configuration matches the default behavior os Jawr, so it actually makes no difference wether you include it in your 
	descriptor or not. You would set these parameters only to change the default behavior, like for example, to remove minification:  
	
+------------------------------------------+
	jawr.js.bundle.factory.bundlepostprocessors=license		
	jawr.css.bundle.factory.bundlepostprocessors=license
+------------------------------------------+
	
	Optionally, you may specify a different set of postprocessors for any given bundle, so you can mix and match different schemes within your 
	application. In order to do that, you specify similar attributes for a particular bundle: 
	
+------------------------------------------+

	jawr.js.bundle.foo.bundlepostprocessors=license
	jawr.js.bundle.foo.fileprocessors=none
	
+------------------------------------------+

	In this example, the bundle postprocessor for the <foo> bundle is set to <license>, meaning no minification will occur. And for the file-by-file
	postprocessor, it is specified that none will be used. 
	
	<<Custom postprocessors>>
	
	You can also implement your own postprocessor components  (for js, css, or both) to perform any functionality not offered by the included ones. 
	To do that, you must create a class with a no-params constructor that implements the interface 
	<net.jawr.web.resource.bundle.postprocess.ResourceBundlePostProcessor>. 
	This interface defines a single method: 
	
+------------------------------------------+
	/**
	 * Postprocess a bundle of resources. 
	 * @param StringBuffer Joined resources. 
	 * @return StringBuffer a buffer containing the postprocessed bundle. 
	 */
	public StringBuffer postProcessBundle(BundleProcessingStatus status,StringBuffer bundleString);
+------------------------------------------+	

	The first parameter is an object which encapsulates the status of a bundling process and also gives you acces to Jawr configuration plus other 
	data which may be useful under certain circumstances. Most of the time, though, you won't need to use it at all. 
	
	The bundleString StringBuffer will contain different data depending on wether the postprocessor is used as a bundle postprocessor or a file postprocessor. In the
	first case, it will contain the text for the whole bundle, while in the latter case it will contain the text for just a single item in the bundle. 
	
	Finally, the return StringBuffer should contain the bundleString data after it is modified by the postprocessor. As an example, here is an 
	implementation of a postprocessor which we would use to wrap all our scripts in a function that is inmediately executed: 
		
+------------------------------------------+
package net.jawr.test;
// [import statements...]

public class FunctionWrapperPostProcessor implements ResourceBundlePostProcessor {
	
	public StringBuffer postProcessBundle(BundleProcessingStatus status,StringBuffer bundleString) {
		StringBuffer ret = new StringBuffer();
		ret.append("function(){");
		ret.append(bundleString);
		ret.append("}()");
		return ret;
	}
}
+------------------------------------------+	

	To use this postprocessor with our application, we need to declare it in the properties configuration, by giving it a name and declaring the class 
	so that Jawr may create an instance when starting up. The name you give to your postprocessor can then be used to define the bundlepostprocessors 
	and filepostprocessors properties, thus allowing you to create a chain that combines your postprocessors with those of Jawr. For example, the 
	following configuration would add two custom postprocessors named <func> and <sample> and map them in different postprocessing chains: 
	
		
+------------------------------------------+
jawr.custom.postprocessors.names=func,sample
jawr.custom.postprocessors.func.class=net.jawr.test.FunctionWrapperPostProcessor
jawr.custom.postprocessors.sample.class=net.jawr.test.SamplePostProcessor

jawr.js.bundle.factory.bundlepostprocessors=JSMin,func,sample,license
jawr.js.bundle.foo.bundlepostprocessors=license=func,license
+------------------------------------------+		
	

* Jawr included postprocessors reference

*	All-around postprocessors

<<Licenses includer>>
	
	* <<Type>>: Bundle
	
	* <<Properties Key>>: license
	
	[]
	
	The licenses includer will add the content of .license files at the top of a bundle. That way you will be able to add open source mandatory licenses 
	or any other comment to the top of your resources. Check the {{{./license_files.html}license files page}} for more info. 

=====================
	Note that licenses are themselves code comments, so you should be careful to always use this processor after any minification or compression 
	processor has executed and not before. Otherwise, the license might be eliminated from the bundle right after it was inserted. 

=====================


<<YUI compressor>>
	
	* <<Type>>: Bundle
	
	* <<Properties Key>>: YUI, YUIobf
	
	[]
		
	
	This processor uses {{{http://developer.yahoo.com/yui/compressor/} Julien Lecomte's YUI compressor}}. 
	This is a javascript and CSS minification tool that can also perform code obfuscation in the case of javascript bundles. If you 
	want obfuscation, you should use the <<YUIobf>> key when defining postprocessors, but remember that this is only valid for javascript 
	bundles. For CSS files, this is the default minification tool. The YUI compressor has an advantage over JSMin and Jawr's custom CSS 
	compressor in that it will achieve better minification. On the other hand it will add a dependency to the YUI compressor and Rhino 
	libraries. You can get YUI {{{http://www.julienlecomte.net/yuicompressor/} here}}, and rhino 
	{{{http://www.mozilla.org/rhino/download.html} here}}. 
	Maven users can get both by adding a single dependency, like this: 	
	
+------------------------------------------+
	<dependency>
	    <groupId>com.yahoo.platform.yui</groupId>
	    <artifactId>yuicompressor</artifactId>
	    <version>2.2.5</version>
	</dependency>
+------------------------------------------+
	
	Unfortunately, this is the only way I know to get YUI from maven, and it is somewhat ugly since it will include both the YUI compressor and 
	rhino, which might be problematic if you already have rhino on your server's classpath. 
	

*	Javascript-specific postprocessors

<<JSMin>>
	
	* <<Type>>: Bundle
	
	* <<Properties Key>>: JSMin
	
	[]
	
	
	
	This processor uses {{{http://www.crockford.com/javascript/jsmin.html}Douglas Crockford's JSMin}}  minificator. It will remove any comments in code and unnecesary whitespace in a very safe manner.  


*	CSS-specific postprocessors

<<CSS Minificator>>
	
	* <<Type>>: Bundle
	
	* <<Properties Key>>: cssminify
	
	[]
	
	This processor removes comments and unneeded whitespace using search and replace with regular expressions. While it works fine most of the 
	time, it has some known problems (it doesn't work if you have declarations with whitespace other than spaces between rules). While not 
	deprecated, it is recommended to use YUI instead, which is the default anyway. 
		  

<<CSS Path rewriter>>
	
	* <<Type>>: File
	
	* <<Properties Key>>: csspathrewriter
	
	[]
	
	This processor rewrites relative paths in URLs for each file that is added to a bundle. A bundle will have a different URL to that of its contained 
	resources, so in order for relative paths to image files and the like to keep working, URLs must be rewritten accordingly.  
	
